# Nandgame_in_C


## 概述
這個程式是受到程式設計實驗課(雖然我沒有修) “ Lab of programming Week 4 question 2 ”，其中第一句描述 “ Logic gates is the basic of any computers. ” ，以及 Nandgame 所啟發，並藉由單一種 Universal Gate 實作出一個可以編成的電腦。
這個電腦只有 2 個 Registers、64 Bytes，允許32個Instructions 的編寫，時脈取決於當前執行的設備。其中 ALU 的設計讓Instruction可以有最基本的加減法和邏輯，更詳細的細節可以到檔案裡面看。

## 操作
執行程式後，寫入 32 條電腦欲執行 Instruction 對應的 Machine Code 和欲執行的 Instruction 次數，對應表在最後一頁。接著編譯並執行程式，程式最後會印出執行後的 memory 和 register。

## 範例
### 簡單的加法、減法

**2023 + 2024 – 8763**

※	計算
| Code | Instruction |
| ------- | ------- |
| A = 2023 | 0000 0111 1110 0111 |
| D = A | 1000 0100 1001 0000 |
| A = 2024	|	0000 0111 1110 1000 |
| D = D + A	|	1000 0100 0001 0000 |
| A = 8763 | 0010 0010 0011 1011 |
| D = D - A	|	1000 0110 0001 0000 |

※	Push 答案，假設 Stack Pointer 在記憶體位置 31
| Code | Instruction |
| ------- | ------- |
| A = 31 | 0000 0000 0001 1111 |
| A = *A	| 1001 0100 1010 0000 |
| *A = D | 1000 0100 1100 1000 |
| A = 31 | 0000 0000 0001 1111 |
| *A = *A + 1 | 1001 0101 0100 1000 |

**答案 Memory[0] : 11101101100101002 = -471610**

```
0000011111100111
1000010010010000
0000011111101000
1000010000010000
0010001000111011
1000011000010000
0000000000011111
1001010010100000
1000010011001000
0000000000011111
1001010101001000
0000000000000000
0000000000000000
0000000000000000
0000000000000000
0000000000000000
0000000000000000
0000000000000000
0000000000000000
0000000000000000
0000000000000000
0000000000000000
0000000000000000
0000000000000000
0000000000000000
0000000000000000
0000000000000000
0000000000000000
0000000000000000
0000000000000000
0000000000000000
0000000000000000
11
```

### 簡單的乘法 (由於沒有乘法器，因此需要拆成迴圈做加法)

**16 * 281**

※	Memory[0]、[1]、[2]:被乘數(迴圈次數)、乘數、累加數

| Code | Instruction |
| ------- | ------- |
| A = 16 | 0000 0000 0001 0000 |
| A = A – 1	| 1000 0111 0110 0000 |
| D = A	| 1000 0100 1001 0000 |
| A = 0	| 0000 0000 0000 0000 |
| *A = D	| 1000 0100 1100 1000 |
| A = 281	| 0000 0001 0001 1001 |
| D = A	| 1000 0100 1001 0000 |
| A = 1	| 0000 0000 0000 0001 |
| *A = D	| 1000 0100 1100 1000 |
| A = 2	| 0000 0000 0000 0010 |
| *A = D	| 1000 0100 1100 1000 |

※	迴圈開始
| Code | Instruction |
| ------- | ------- |
| A = 2 | 0000 0000 0000 0010 |
| D = *A | 1001 0100 1001 0000 |
| A = 1 | 0000 0000 0000 0001 |
| D = D + *A | 1001 0100 0001 0000 |
| A = 0 | 0000 0000 0000 0000 |
| *A = *A – 1 | 1001 0111 0100 1000 |
| A = 2 | 0000 0000 0000 0010 |
| *A = D | 1000 0100 1100 1000 |
| A = 0 | 0000 0000 0000 0000 |
| D = *A | 1001 0100 1001 0000 |
| A = 25 | 0000 0000 0001 1001 |
| D JEQ | 1000 0100 1100 0010 |
| A = 11 | 0000 0000 0000 1011 |
| JMP | 1000 0000 0000 0111 |

※	當上述迴圈結束時跳到這裡
※	無限迴圈，直到 Instruction 數量跑完
| Code | Instruction |
| ------- | ------- |
| A = 2 | 0000 0000 0000 0010 |
| D = *A | 1001 0100 1001 0000 |
| A = 28 | 0000 0000 0001 1100 |
| JMP | 1000 0000 0000 0111 |

**答案 Register[1] : 00010001100100002 = 449610**

### 費氏數列

**Fib(n) = 1, 1, 2, 3, 5, 8, 13, 21, …**
| Code | Instruction |
| ------- | ------- |
| A = 1 | 0000 0000 0000 0001 |
| D = A | 1000 0100 1001 0000 |

※	迴圈，把算出來的每一項 Push 到Stack 裡
| Code | Instruction |
| ------- | ------- |
| A = 31 | 0000 0000 0001 1111 |
| A = *A | 1001 0100 1010 0000 |
| *A = D | 1000 0100 1100 1000 |
| A = 31 | 0000 0000 0001 1111 |
| *A = *A + 1 | 1001 0101 0100 1000 |

※	計算
| Code | Instruction |
| ------- | ------- |
| A = 30 | 0000 0000 0001 1110 |
| D = D + *A | 1001 0100 0001 0000 |
| *A = D – *A | 1001 0110 0000 1000 |
| A = 2 | 0000 0000 0000 0010 |
| JMP | 1000 0000 0000 0111 |

**答案 	Memory[0] : 00000000000000012 = 110**
**Memory[1] : 00000000000000012 = 110**
**Memory[2] : 00000000000000102 = 210**
**Memory[3] : 00000000000000112 = 310**
**Memory[4] : 00000000000001012 = 510 …**
